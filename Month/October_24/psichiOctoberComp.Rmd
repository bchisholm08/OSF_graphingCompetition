---
title: "psichiOctoberComp"
author: "Brady M. Chisholm"
date: "2024-10-26"
output: html_document
---

### Load Data & packages 
```{r setup}
# suppress from knitted output? 
# List required packages
required_packages <- c("rvest", "tidyverse", "ggplot2", "tidyr", "dplyr", "lubridate", "scales", "patchwork")
# check, install if missing 
suppressMessages(suppressWarnings({
  for (pkg in required_packages) {
    if (!require(pkg, character.only = TRUE)) {
      install.packages(pkg)
    }
    library(pkg, character.only = TRUE)
  }
}))
# use osf url, my github crashed? 
horrorDataUrl <- "https://osf.io/download/mxs49/?direct&mode=render"
```

### Data Processing Level 1 
```{r}
# read in from url 
HorrorIMDB <- read.csv(horrorDataUrl)

# Filter out movies that are missing a value in budget, runtime, parentalrating, and rating column 
cleanedMovies <- HorrorIMDB %>%
  filter(!is.na(Budget), !is.na(RunTime), !is.na(ParentalRating), !is.na(Rating))

# Separate the 'Genre' column into multiple genre categories
# Assuming 'Genre' column contains strings like "Action| Fantasy| Horror| Mystery| Romance"
# This separates each genre into its own column

# Separate genre column into multiple categories 
genreSorted <- cleanedMovies %>%
  separate_rows(Genres, sep = "\\|") %>%
  mutate(Genre = trimws(Genres)) # trim any white space  we created 
```

### Descriptive Statistics Level 2
```{r}
# Avg, std, median, range of rating variable 
summaryStat <- function(myDat){
  
  avg <- mean(myDat, na.rm = TRUE)
  std <- sd(myDat, na.rm = TRUE)
  med <- median(myDat, na.rm = TRUE)
  rg <- range(myDat, na.rm = TRUE)
  # organize results and make them print in a pretty way. Alt data frame? 
  stats_df <- data.frame(
    Descriptive_Stat = c("Average", "Standard Deviation", "Median", "Range"),
    Value = c(round(avg, 2), round(std, 2), round(med, 2), paste("(", rg[1], " to ", rg[2], ")", sep = ""))) # clean up values for printing 
  
  print(stats_df, row.names = FALSE)
  
  # suppress output, just print cleaned df 
  invisible(list(avg = avg, std = std, med = med, range = rg))} # function end 

summaryStat(HorrorIMDB$Rating)
```

#Descriptive stats pt 2, average rating by a movies main genre. Handle NaN's?  
```{r}
# Define the function to calculate the average rating by main genre
genreAvg <- function(data) {
  # uses dyplr, ensure install earlier in script 
  
  # Check for required columns in data
  if (!all(c("Genre","Genre", "Rating") %in% colnames(data))) { #FIXME %in% ?? 
    # throw error if we don't have enough info 
    stop("Data must contain genre and rating data")}
  
  # Calculate rating for each genre 
  genre_avg_df <- data %>% # FIXME double pipe? 
    group_by(Genre) %>% # use genre as grouper 
    summarise(Average_Rating = mean(Rating, na.rm = TRUE)) %>%
    arrange(desc(Average_Rating)) # Sort by average rating, highest first 
  
  # Print pretty results
  print(genre_avg_df, row.names = FALSE)
  
  # return table but suppress 
  invisible(genre_avg_df)} # function end 

# test function 
genreAvg(genreSorted) # only working function call with cleaned data 
#   genreAvg(HorrorIMDB) #FIXME doesn't handle unsorted data. Or is it NaN? 
#   genreAvg(cleanedMovies)
```

### Data Visualization Level 3 
```{r data wrangle first}
# Graph budget of movies  over time 
# req packages 
# clean up data first. Need to extract year for plotting
HorrorIMDB <- HorrorIMDB %>%
  mutate(Release_Date = mdy(Release_Date),  # Convert to date
         Year = year(Release_Date),         # Extract year 
         Budget_Million = Budget / 1e6) #%>%  # Convert Budget to millions

# bad code. Filter was removing all low values 
  #filter(!is.na(Year) & !is.na(Budget) & Year >= 1925)  # setting year to 1925 omits n ..? 
HorrorIMDB <- HorrorIMDB %>%
  filter(!is.na(Year))

# divide data into early and late 
early_data <- HorrorIMDB %>% filter(Year <= 1905)
later_data <- HorrorIMDB %>% filter(Year >= 1910)
```

```{r} 
# misc color junk. cool plot though 
jet.colors <-
  colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                     "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
filled.contour(volcano, color.palette = jet.colors, asp = 1)
```

after cleaning we can finally plot
```{r}
# first plot early data 
early_plot <- ggplot(early_data, aes(x= Year,y =  Budget_Million)) +
  geom_jitter(color = "black", alpha = 0.7, width = 0.25, size = 2) + # only one year, distribute points
  scale_y_continuous(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  labs(
      title = "Movie Budgets in 1905",
       x = "1905", 
       y = "Budget in Millions $") +
  theme_minimal() + 
    theme(
      panel.grid = element_line(color = "orange"),
      panel.grid.major.x = element_line(color = "orange"),
      panel.grid.major.y = element_line(color = "black"),
      axis.ticks.y = element_line(color = "black"),
      axis.ticks.x = element_line(color = "black"),
      plot.title = element_text(face = "bold", size = 9, hjust = .95, color = "black"),
      plot.background = element_rect(fill = "orange"),
      axis.text.y = element_text(family = "serif",color = "black",face = "bold"),
      axis.text.x = element_text(color = "orange"),
      axis.line.x = element_line(color = "black"),
      axis.line.y = element_line(color = "black"),
      text = element_text(family = "serif", color = "black",size = 12, face = "bold")
      ) # close theme 

later_plot <-ggplot(later_data, aes(x = Year, y = Budget_Million)) +
  geom_smooth(method = "glm", linewidth = 1.5, color = "#00CED1", fill = "orange", na.rm = TRUE, se = TRUE,span = 1, level = .98) +
  geom_jitter(color = "white", alpha = 0.55, width = 0.47, size = 2) + 
  scale_y_continuous(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  labs(
    title = "Movie Budgets from 2012 to 2017",
    x = "Year (2012-2017)",
    y = NULL) +
  theme_minimal() +
  theme(
   # text = element_text(family = "serif", color = "ghostwhite"),
     axis.text = element_text(color = "white"),
    text = element_text(family = "serif", color = "black",size = 12, face = "bold"),
    plot.title = element_text(face = "bold", size = 12, hjust = 0.5, color = "white"),
    axis.text.x = element_text(angle = 45, hjust = 0.5, color = "white"),
    axis.title.x = element_text(face = "bold", hjust = 0.5, color = "white"),
    panel.grid = element_line(color = "#8B0000", size = 0.1),
    plot.background = element_rect(fill = "black")
) 

# combine plots, add final aesthetics 
comboPlot <- early_plot + later_plot + plot_layout(ncol = 2, widths = c(0.3, 2.5))
comboPlot + 
  plot_annotation(
    title = "Halloween Movie Budgets Over Time",
    subtitle = "Comparing Budgets from 1905 to Modern Day; 2012-2017",
    theme = theme(
      text = element_text(family = "serif", color = "ghostwhite"),
      plot.title = element_text(face = "bold", size = 18, color = 'maroon', hjust = 0.5),
      plot.subtitle = element_text(face = 'italic', size = 14, color = 'red', hjust = 0.5)))
```

### Inferential Statistics Level 4 
```{r}
# Do movies with bigger budgets get better ratings?? 
cleaned_data <- HorrorIMDB %>%
  filter(!is.na(Budget), !is.na(Rating))

ggplot(cleaned_data, aes(x = Budget, y = Rating)) +
  geom_point(alpha = 0.5, color = "#401F71") +  # Scatter plot
  geom_smooth(method = "lm", color = "red", se = TRUE) +  # Regression line
  scale_x_continuous(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  labs(
    title = "Relationship Between Movie Budget and Rating",
    x = "$ Million of Budget",
    y = "Rating"
  ) +
  theme_minimal()

correlation <- cor(cleaned_data$Budget, cleaned_data$Rating, use = "complete.obs")
print(paste("Correlation between Budget and Rating:", round(correlation, 2)))

# Fit standard linear model
model <- lm(Rating ~ Budget, data = cleaned_data)
summary(model)

### Do movies in the Horror genre get better ratings than mystery movies? 
```

```{r}
# Load necessary libraries


# Step 1: Check available genres in `genreSorted`
print("Available genres in dataset:")
print(unique(genreSorted$Genres))

# Step 2: Filter `genreSorted` for Horror and Mystery genres with non-missing ratings
cleanGenreDat <- genreSorted %>%
  filter(!is.na(Rating), Genres %in% c(" Horror", " Mystery")) # leading space?!? 

# Check that we have both genres after filtering
unique_genres <- unique(cleanGenreDat$Genres)
print("Genres present in the filtered dataset:")
print(unique_genres)

if (length(unique_genres) < 2) {
  stop("Error: Dataset must contain both 'Horror' and 'Mystery' genres for comparison.")
}

# Step 3: Visualize Ratings Comparison with a Boxplot
ggplot(cleanGenreDat, aes(x = Genres, y = Rating, fill = Genres)) +
  geom_boxplot(alpha = 0.7) +
  labs(
    title = "Comparison of Ratings: Horror vs Mystery Movies",
    x = "Genre",
    y = "Rating"
  ) +
  theme_minimal() +
  scale_fill_manual(values = c("Horror" = "#401F71", "Mystery" = "#8B0000"))

# Step 4: Calculate Mean Ratings for Each Genre
genre_means <- cleanGenreDat %>%
  group_by(Genres) %>%
  summarise(Mean_Rating = mean(Rating, na.rm = TRUE))

print("Mean Ratings for Each Genre:")
print(genre_means)

# Step 5: Normality Check and Statistical Test (as per the previous code)
# Follow the same statistical test logic as in the previous response



```

